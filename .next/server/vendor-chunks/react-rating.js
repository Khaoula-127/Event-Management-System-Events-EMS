"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-rating";
exports.ids = ["vendor-chunks/react-rating"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-rating/lib/react-rating.esm.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-rating/lib/react-rating.esm.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction _typeof(obj) {\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n        _typeof = function(obj) {\n            return typeof obj;\n        };\n    } else {\n        _typeof = function(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n        };\n    }\n    return _typeof(obj);\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _extends() {\n    _extends = Object.assign || function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === \"function\") {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n        });\n    }\n    return target;\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n        return call;\n    }\n    return _assertThisInitialized(self);\n}\nvar style = {\n    display: \"inline-block\",\n    borderRadius: \"50%\",\n    border: \"5px double white\",\n    width: 30,\n    height: 30\n};\nvar Style = {\n    empty: _objectSpread({}, style, {\n        backgroundColor: \"#ccc\"\n    }),\n    full: _objectSpread({}, style, {\n        backgroundColor: \"black\"\n    }),\n    placeholder: _objectSpread({}, style, {\n        backgroundColor: \"red\"\n    })\n};\n// Return the corresponding React node for an icon.\nvar _iconNode = function _iconNode(icon) {\n    // If it is already a React Element just return it.\n    if (/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().isValidElement(icon)) {\n        return icon;\n    } // If it is an object, try to use it as a CSS style object.\n    if (_typeof(icon) === \"object\" && icon !== null) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"span\", {\n            style: icon\n        });\n    } // If it is a string, use it as class names.\n    if (Object.prototype.toString.call(icon) === \"[object String]\") {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"span\", {\n            className: icon\n        });\n    }\n};\nvar RatingSymbol = /*#__PURE__*/ function(_React$PureComponent) {\n    _inherits(RatingSymbol, _React$PureComponent);\n    function RatingSymbol() {\n        _classCallCheck(this, RatingSymbol);\n        return _possibleConstructorReturn(this, _getPrototypeOf(RatingSymbol).apply(this, arguments));\n    }\n    _createClass(RatingSymbol, [\n        {\n            key: \"render\",\n            value: function render() {\n                var _iconContainerStyle;\n                var _this$props = this.props, index = _this$props.index, inactiveIcon = _this$props.inactiveIcon, activeIcon = _this$props.activeIcon, percent = _this$props.percent, direction = _this$props.direction, readonly = _this$props.readonly, onClick = _this$props.onClick, onMouseMove = _this$props.onMouseMove;\n                var backgroundNode = _iconNode(inactiveIcon);\n                var showbgIcon = percent < 100;\n                var bgIconContainerStyle = showbgIcon ? {} : {\n                    visibility: \"hidden\"\n                };\n                var iconNode = _iconNode(activeIcon);\n                var iconContainerStyle = (_iconContainerStyle = {\n                    display: \"inline-block\",\n                    position: \"absolute\",\n                    overflow: \"hidden\",\n                    top: 0\n                }, _defineProperty(_iconContainerStyle, direction === \"rtl\" ? \"right\" : \"left\", 0), _defineProperty(_iconContainerStyle, \"width\", \"\".concat(percent, \"%\")), _iconContainerStyle);\n                var style = {\n                    cursor: !readonly ? \"pointer\" : \"inherit\",\n                    display: \"inline-block\",\n                    position: \"relative\"\n                };\n                function handleMouseMove(e) {\n                    if (onMouseMove) {\n                        onMouseMove(index, e);\n                    }\n                }\n                function handleMouseClick(e) {\n                    if (onClick) {\n                        // [Supporting both TouchEvent and MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/Touch_events/Supporting_both_TouchEvent_and_MouseEvent)\n                        // We must prevent firing click event twice on touch devices.\n                        e.preventDefault();\n                        onClick(index, e);\n                    }\n                }\n                return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"span\", {\n                    style: style,\n                    onClick: handleMouseClick,\n                    onMouseMove: handleMouseMove,\n                    onTouchMove: handleMouseMove,\n                    onTouchEnd: handleMouseClick\n                }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"span\", {\n                    style: bgIconContainerStyle\n                }, backgroundNode), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"span\", {\n                    style: iconContainerStyle\n                }, iconNode));\n            }\n        }\n    ]);\n    return RatingSymbol;\n}((react__WEBPACK_IMPORTED_MODULE_0___default().PureComponent)); // Define propTypes only in development. They will be void in production.\nvar Rating = /*#__PURE__*/ function(_React$PureComponent) {\n    _inherits(Rating, _React$PureComponent);\n    function Rating(props) {\n        var _this;\n        _classCallCheck(this, Rating);\n        _this = _possibleConstructorReturn(this, _getPrototypeOf(Rating).call(this, props));\n        _this.state = {\n            // Indicates the value that is displayed to the user in the form of symbols.\n            // It can be either 0 (for no displayed symbols) or (0, end]\n            displayValue: _this.props.value,\n            // Indicates if the user is currently hovering over the rating element\n            interacting: false\n        };\n        _this.onMouseLeave = _this.onMouseLeave.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n        _this.symbolMouseMove = _this.symbolMouseMove.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n        _this.symbolClick = _this.symbolClick.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n        return _this;\n    }\n    _createClass(Rating, [\n        {\n            key: \"UNSAFE_componentWillReceiveProps\",\n            value: function UNSAFE_componentWillReceiveProps(nextProps) {\n                var valueChanged = this.props.value !== nextProps.value;\n                this.setState(function(prevState) {\n                    return {\n                        displayValue: valueChanged ? nextProps.value : prevState.displayValue\n                    };\n                });\n            }\n        },\n        {\n            key: \"componentDidUpdate\",\n            value: function componentDidUpdate(prevProps, prevState) {\n                // Ignore state update due to value changed from props.\n                // Usually originated through an onClick event.\n                if (prevProps.value !== this.props.value) {\n                    return;\n                } // When hover ends, call this.props.onHover with no value.\n                if (prevState.interacting && !this.state.interacting) {\n                    return this.props.onHover();\n                } // When hover over.\n                if (this.state.interacting) {\n                    this.props.onHover(this.state.displayValue);\n                }\n            }\n        },\n        {\n            key: \"symbolClick\",\n            value: function symbolClick(symbolIndex, event) {\n                var value = this.calculateDisplayValue(symbolIndex, event);\n                this.props.onClick(value, event);\n            }\n        },\n        {\n            key: \"symbolMouseMove\",\n            value: function symbolMouseMove(symbolIndex, event) {\n                var value = this.calculateDisplayValue(symbolIndex, event); // This call should cause an update only if the state changes.\n                // Mainly the first time the mouse enters and whenever the value changes.\n                // So DidComponentUpdate is NOT called for every mouse movement.\n                this.setState({\n                    interacting: !this.props.readonly,\n                    displayValue: value\n                });\n            }\n        },\n        {\n            key: \"onMouseLeave\",\n            value: function onMouseLeave() {\n                this.setState({\n                    displayValue: this.props.value,\n                    interacting: false\n                });\n            }\n        },\n        {\n            key: \"calculateDisplayValue\",\n            value: function calculateDisplayValue(symbolIndex, event) {\n                var percentage = this.calculateHoverPercentage(event); // Get the closest top fraction.\n                var fraction = Math.ceil(percentage % 1 * this.props.fractions) / this.props.fractions; // Truncate decimal trying to avoid float precission issues.\n                var precision = Math.pow(10, 3);\n                var displayValue = symbolIndex + (Math.floor(percentage) + Math.floor(fraction * precision) / precision); // ensure the returned value is greater than 0 and lower than totalSymbols\n                return displayValue > 0 ? displayValue > this.props.totalSymbols ? this.props.totalSymbols : displayValue : 1 / this.props.fractions;\n            }\n        },\n        {\n            key: \"calculateHoverPercentage\",\n            value: function calculateHoverPercentage(event) {\n                var clientX = event.nativeEvent.type.indexOf(\"touch\") > -1 ? event.nativeEvent.type.indexOf(\"touchend\") > -1 ? event.changedTouches[0].clientX : event.touches[0].clientX : event.clientX;\n                var targetRect = event.target.getBoundingClientRect();\n                var delta = this.props.direction === \"rtl\" ? targetRect.right - clientX : clientX - targetRect.left; // Returning 0 if the delta is negative solves the flickering issue\n                return delta < 0 ? 0 : delta / targetRect.width;\n            }\n        },\n        {\n            key: \"render\",\n            value: function render() {\n                var _this$props = this.props, readonly = _this$props.readonly, quiet = _this$props.quiet, totalSymbols = _this$props.totalSymbols, value = _this$props.value, placeholderValue = _this$props.placeholderValue, direction = _this$props.direction, emptySymbol = _this$props.emptySymbol, fullSymbol = _this$props.fullSymbol, placeholderSymbol = _this$props.placeholderSymbol, className = _this$props.className, id = _this$props.id, style = _this$props.style, tabIndex = _this$props.tabIndex;\n                var _this$state = this.state, displayValue = _this$state.displayValue, interacting = _this$state.interacting;\n                var symbolNodes = [];\n                var empty = [].concat(emptySymbol);\n                var full = [].concat(fullSymbol);\n                var placeholder = [].concat(placeholderSymbol);\n                var shouldDisplayPlaceholder = placeholderValue !== 0 && value === 0 && !interacting; // The value that will be used as base for calculating how to render the symbols\n                var renderedValue;\n                if (shouldDisplayPlaceholder) {\n                    renderedValue = placeholderValue;\n                } else {\n                    renderedValue = quiet ? value : displayValue;\n                } // The amount of full symbols\n                var fullSymbols = Math.floor(renderedValue);\n                for(var i = 0; i < totalSymbols; i++){\n                    var percent = void 0; // Calculate each symbol's fullness percentage\n                    if (i - fullSymbols < 0) {\n                        percent = 100;\n                    } else if (i - fullSymbols === 0) {\n                        percent = (renderedValue - i) * 100;\n                    } else {\n                        percent = 0;\n                    }\n                    symbolNodes.push(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(RatingSymbol, _extends({\n                        key: i,\n                        index: i,\n                        readonly: readonly,\n                        inactiveIcon: empty[i % empty.length],\n                        activeIcon: shouldDisplayPlaceholder ? placeholder[i % full.length] : full[i % full.length],\n                        percent: percent,\n                        direction: direction\n                    }, !readonly && {\n                        onClick: this.symbolClick,\n                        onMouseMove: this.symbolMouseMove,\n                        onTouchMove: this.symbolMouseMove,\n                        onTouchEnd: this.symbolClick\n                    })));\n                }\n                return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"span\", _extends({\n                    id: id,\n                    style: _objectSpread({}, style, {\n                        display: \"inline-block\",\n                        direction: direction\n                    }),\n                    className: className,\n                    tabIndex: tabIndex,\n                    \"aria-label\": this.props[\"aria-label\"]\n                }, !readonly && {\n                    onMouseLeave: this.onMouseLeave\n                }), symbolNodes);\n            }\n        }\n    ]);\n    return Rating;\n}((react__WEBPACK_IMPORTED_MODULE_0___default().PureComponent)); // Define propTypes only in development.\nfunction noop() {}\nnoop._name = \"react_rating_noop\";\nvar RatingAPILayer = /*#__PURE__*/ function(_React$PureComponent) {\n    _inherits(RatingAPILayer, _React$PureComponent);\n    function RatingAPILayer(props) {\n        var _this;\n        _classCallCheck(this, RatingAPILayer);\n        _this = _possibleConstructorReturn(this, _getPrototypeOf(RatingAPILayer).call(this, props));\n        _this.state = {\n            value: props.initialRating\n        };\n        _this.handleClick = _this.handleClick.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n        _this.handleHover = _this.handleHover.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n        return _this;\n    }\n    _createClass(RatingAPILayer, [\n        {\n            key: \"UNSAFE_componentWillReceiveProps\",\n            value: function UNSAFE_componentWillReceiveProps(nextProps) {\n                this.setState({\n                    value: nextProps.initialRating\n                });\n            }\n        },\n        {\n            key: \"handleClick\",\n            value: function handleClick(value, e) {\n                var _this2 = this;\n                var newValue = this.translateDisplayValueToValue(value);\n                this.props.onClick(newValue); // Avoid calling setState if not necessary. Micro optimisation.\n                if (this.state.value !== newValue) {\n                    // If we have a new value trigger onChange callback.\n                    this.setState({\n                        value: newValue\n                    }, function() {\n                        return _this2.props.onChange(_this2.state.value);\n                    });\n                }\n            }\n        },\n        {\n            key: \"handleHover\",\n            value: function handleHover(displayValue) {\n                var value = displayValue === undefined ? displayValue : this.translateDisplayValueToValue(displayValue);\n                this.props.onHover(value);\n            }\n        },\n        {\n            key: \"translateDisplayValueToValue\",\n            value: function translateDisplayValueToValue(displayValue) {\n                var translatedValue = displayValue * this.props.step + this.props.start; // minimum value cannot be equal to start, since it's exclusive\n                return translatedValue === this.props.start ? translatedValue + 1 / this.props.fractions : translatedValue;\n            }\n        },\n        {\n            key: \"tranlateValueToDisplayValue\",\n            value: function tranlateValueToDisplayValue(value) {\n                if (value === undefined) {\n                    return 0;\n                }\n                return (value - this.props.start) / this.props.step;\n            }\n        },\n        {\n            key: \"render\",\n            value: function render() {\n                var _this$props = this.props, step = _this$props.step, emptySymbol = _this$props.emptySymbol, fullSymbol = _this$props.fullSymbol, placeholderSymbol = _this$props.placeholderSymbol, readonly = _this$props.readonly, quiet = _this$props.quiet, fractions = _this$props.fractions, direction = _this$props.direction, start = _this$props.start, stop = _this$props.stop, id = _this$props.id, className = _this$props.className, style = _this$props.style, tabIndex = _this$props.tabIndex;\n                function calculateTotalSymbols(start, stop, step) {\n                    return Math.floor((stop - start) / step);\n                }\n                return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Rating, {\n                    id: id,\n                    style: style,\n                    className: className,\n                    tabIndex: tabIndex,\n                    \"aria-label\": this.props[\"aria-label\"],\n                    totalSymbols: calculateTotalSymbols(start, stop, step),\n                    value: this.tranlateValueToDisplayValue(this.state.value),\n                    placeholderValue: this.tranlateValueToDisplayValue(this.props.placeholderRating),\n                    readonly: readonly,\n                    quiet: quiet,\n                    fractions: fractions,\n                    direction: direction,\n                    emptySymbol: emptySymbol,\n                    fullSymbol: fullSymbol,\n                    placeholderSymbol: placeholderSymbol,\n                    onClick: this.handleClick,\n                    onHover: this.handleHover\n                });\n            }\n        }\n    ]);\n    return RatingAPILayer;\n}((react__WEBPACK_IMPORTED_MODULE_0___default().PureComponent));\nRatingAPILayer.defaultProps = {\n    start: 0,\n    stop: 5,\n    step: 1,\n    readonly: false,\n    quiet: false,\n    fractions: 1,\n    direction: \"ltr\",\n    onHover: noop,\n    onClick: noop,\n    onChange: noop,\n    emptySymbol: Style.empty,\n    fullSymbol: Style.full,\n    placeholderSymbol: Style.placeholder\n}; // Define propTypes only in development.\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RatingAPILayer);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmF0aW5nL2xpYi9yZWFjdC1yYXRpbmcuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUEwQjtBQUUxQixTQUFTQyxRQUFRQyxHQUFHO0lBQ2xCLElBQUksT0FBT0MsV0FBVyxjQUFjLE9BQU9BLE9BQU9DLFFBQVEsS0FBSyxVQUFVO1FBQ3ZFSCxVQUFVLFNBQVVDLEdBQUc7WUFDckIsT0FBTyxPQUFPQTtRQUNoQjtJQUNGLE9BQU87UUFDTEQsVUFBVSxTQUFVQyxHQUFHO1lBQ3JCLE9BQU9BLE9BQU8sT0FBT0MsV0FBVyxjQUFjRCxJQUFJRyxXQUFXLEtBQUtGLFVBQVVELFFBQVFDLE9BQU9HLFNBQVMsR0FBRyxXQUFXLE9BQU9KO1FBQzNIO0lBQ0Y7SUFFQSxPQUFPRCxRQUFRQztBQUNqQjtBQUVBLFNBQVNLLGdCQUFnQkMsUUFBUSxFQUFFQyxXQUFXO0lBQzVDLElBQUksQ0FBRUQsQ0FBQUEsb0JBQW9CQyxXQUFVLEdBQUk7UUFDdEMsTUFBTSxJQUFJQyxVQUFVO0lBQ3RCO0FBQ0Y7QUFFQSxTQUFTQyxrQkFBa0JDLE1BQU0sRUFBRUMsS0FBSztJQUN0QyxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUQsTUFBTUUsTUFBTSxFQUFFRCxJQUFLO1FBQ3JDLElBQUlFLGFBQWFILEtBQUssQ0FBQ0MsRUFBRTtRQUN6QkUsV0FBV0MsVUFBVSxHQUFHRCxXQUFXQyxVQUFVLElBQUk7UUFDakRELFdBQVdFLFlBQVksR0FBRztRQUMxQixJQUFJLFdBQVdGLFlBQVlBLFdBQVdHLFFBQVEsR0FBRztRQUNqREMsT0FBT0MsY0FBYyxDQUFDVCxRQUFRSSxXQUFXTSxHQUFHLEVBQUVOO0lBQ2hEO0FBQ0Y7QUFFQSxTQUFTTyxhQUFhZCxXQUFXLEVBQUVlLFVBQVUsRUFBRUMsV0FBVztJQUN4RCxJQUFJRCxZQUFZYixrQkFBa0JGLFlBQVlILFNBQVMsRUFBRWtCO0lBQ3pELElBQUlDLGFBQWFkLGtCQUFrQkYsYUFBYWdCO0lB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SSxLQUFLLENBQUMsYUFBYTtvQkFDdEMwSCxjQUFjeUMsc0JBQXNCSCxPQUFPRSxNQUFNSDtvQkFDakRqSixPQUFPLElBQUksQ0FBQ21KLDJCQUEyQixDQUFDLElBQUksQ0FBQ2xFLEtBQUssQ0FBQ2pGLEtBQUs7b0JBQ3hEeUgsa0JBQWtCLElBQUksQ0FBQzBCLDJCQUEyQixDQUFDLElBQUksQ0FBQ2pLLEtBQUssQ0FBQ29LLGlCQUFpQjtvQkFDL0UzRixVQUFVQTtvQkFDVjZELE9BQU9BO29CQUNQaEIsV0FBV0E7b0JBQ1g5QyxXQUFXQTtvQkFDWGdFLGFBQWFBO29CQUNiQyxZQUFZQTtvQkFDWkMsbUJBQW1CQTtvQkFDbkJoRSxTQUFTLElBQUksQ0FBQzZFLFdBQVc7b0JBQ3pCMUMsU0FBUyxJQUFJLENBQUMyQyxXQUFXO2dCQUMzQjtZQUNGO1FBQ0Y7S0FBRTtJQUVGLE9BQU9IO0FBQ1QsRUFBRWxLLDREQUFtQjtBQUVyQmtLLGVBQWVnQixZQUFZLEdBQUc7SUFDNUJMLE9BQU87SUFDUEUsTUFBTTtJQUNOSCxNQUFNO0lBQ050RixVQUFVO0lBQ1Y2RCxPQUFPO0lBQ1BoQixXQUFXO0lBQ1g5QyxXQUFXO0lBQ1hxQyxTQUFTc0M7SUFDVHpFLFNBQVN5RTtJQUNUUyxVQUFVVDtJQUNWWCxhQUFhcEYsTUFBTUMsS0FBSztJQUN4Qm9GLFlBQVlyRixNQUFNRyxJQUFJO0lBQ3RCbUYsbUJBQW1CdEYsTUFBTUksV0FBVztBQUN0QyxHQUFHLHdDQUF3QztBQUUzQyxpRUFBZTZGLGNBQWNBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9FTVMvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmF0aW5nL2xpYi9yZWFjdC1yYXRpbmcuZXNtLmpzP2ZmODIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuICAgIHZhciBvd25LZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcblxuICAgIGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb3duS2V5cyA9IG93bktleXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKS5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIHN5bSkuZW51bWVyYWJsZTtcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBvd25LZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9XG5cbiAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5cbnZhciBzdHlsZSA9IHtcbiAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG4gIGJvcmRlclJhZGl1czogJzUwJScsXG4gIGJvcmRlcjogJzVweCBkb3VibGUgd2hpdGUnLFxuICB3aWR0aDogMzAsXG4gIGhlaWdodDogMzBcbn07XG52YXIgU3R5bGUgPSB7XG4gIGVtcHR5OiBfb2JqZWN0U3ByZWFkKHt9LCBzdHlsZSwge1xuICAgIGJhY2tncm91bmRDb2xvcjogJyNjY2MnXG4gIH0pLFxuICBmdWxsOiBfb2JqZWN0U3ByZWFkKHt9LCBzdHlsZSwge1xuICAgIGJhY2tncm91bmRDb2xvcjogJ2JsYWNrJ1xuICB9KSxcbiAgcGxhY2Vob2xkZXI6IF9vYmplY3RTcHJlYWQoe30sIHN0eWxlLCB7XG4gICAgYmFja2dyb3VuZENvbG9yOiAncmVkJ1xuICB9KVxufTtcblxuLy8gUmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nIFJlYWN0IG5vZGUgZm9yIGFuIGljb24uXG52YXIgX2ljb25Ob2RlID0gZnVuY3Rpb24gX2ljb25Ob2RlKGljb24pIHtcbiAgLy8gSWYgaXQgaXMgYWxyZWFkeSBhIFJlYWN0IEVsZW1lbnQganVzdCByZXR1cm4gaXQuXG4gIGlmIChSZWFjdC5pc1ZhbGlkRWxlbWVudChpY29uKSkge1xuICAgIHJldHVybiBpY29uO1xuICB9IC8vIElmIGl0IGlzIGFuIG9iamVjdCwgdHJ5IHRvIHVzZSBpdCBhcyBhIENTUyBzdHlsZSBvYmplY3QuXG5cblxuICBpZiAoX3R5cGVvZihpY29uKSA9PT0gJ29iamVjdCcgJiYgaWNvbiAhPT0gbnVsbCkge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgICBzdHlsZTogaWNvblxuICAgIH0pO1xuICB9IC8vIElmIGl0IGlzIGEgc3RyaW5nLCB1c2UgaXQgYXMgY2xhc3MgbmFtZXMuXG5cblxuICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGljb24pID09PSAnW29iamVjdCBTdHJpbmddJykge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgICBjbGFzc05hbWU6IGljb25cbiAgICB9KTtcbiAgfVxufTtcblxudmFyIFJhdGluZ1N5bWJvbCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1JlYWN0JFB1cmVDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFJhdGluZ1N5bWJvbCwgX1JlYWN0JFB1cmVDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFJhdGluZ1N5bWJvbCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmF0aW5nU3ltYm9sKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoUmF0aW5nU3ltYm9sKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhSYXRpbmdTeW1ib2wsIFt7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX2ljb25Db250YWluZXJTdHlsZTtcblxuICAgICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBpbmRleCA9IF90aGlzJHByb3BzLmluZGV4LFxuICAgICAgICAgIGluYWN0aXZlSWNvbiA9IF90aGlzJHByb3BzLmluYWN0aXZlSWNvbixcbiAgICAgICAgICBhY3RpdmVJY29uID0gX3RoaXMkcHJvcHMuYWN0aXZlSWNvbixcbiAgICAgICAgICBwZXJjZW50ID0gX3RoaXMkcHJvcHMucGVyY2VudCxcbiAgICAgICAgICBkaXJlY3Rpb24gPSBfdGhpcyRwcm9wcy5kaXJlY3Rpb24sXG4gICAgICAgICAgcmVhZG9ubHkgPSBfdGhpcyRwcm9wcy5yZWFkb25seSxcbiAgICAgICAgICBvbkNsaWNrID0gX3RoaXMkcHJvcHMub25DbGljayxcbiAgICAgICAgICBvbk1vdXNlTW92ZSA9IF90aGlzJHByb3BzLm9uTW91c2VNb3ZlO1xuXG4gICAgICB2YXIgYmFja2dyb3VuZE5vZGUgPSBfaWNvbk5vZGUoaW5hY3RpdmVJY29uKTtcblxuICAgICAgdmFyIHNob3diZ0ljb24gPSBwZXJjZW50IDwgMTAwO1xuICAgICAgdmFyIGJnSWNvbkNvbnRhaW5lclN0eWxlID0gc2hvd2JnSWNvbiA/IHt9IDoge1xuICAgICAgICB2aXNpYmlsaXR5OiAnaGlkZGVuJ1xuICAgICAgfTtcblxuICAgICAgdmFyIGljb25Ob2RlID0gX2ljb25Ob2RlKGFjdGl2ZUljb24pO1xuXG4gICAgICB2YXIgaWNvbkNvbnRhaW5lclN0eWxlID0gKF9pY29uQ29udGFpbmVyU3R5bGUgPSB7XG4gICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgICB0b3A6IDBcbiAgICAgIH0sIF9kZWZpbmVQcm9wZXJ0eShfaWNvbkNvbnRhaW5lclN0eWxlLCBkaXJlY3Rpb24gPT09ICdydGwnID8gJ3JpZ2h0JyA6ICdsZWZ0JywgMCksIF9kZWZpbmVQcm9wZXJ0eShfaWNvbkNvbnRhaW5lclN0eWxlLCBcIndpZHRoXCIsIFwiXCIuY29uY2F0KHBlcmNlbnQsIFwiJVwiKSksIF9pY29uQ29udGFpbmVyU3R5bGUpO1xuICAgICAgdmFyIHN0eWxlID0ge1xuICAgICAgICBjdXJzb3I6ICFyZWFkb25seSA/ICdwb2ludGVyJyA6ICdpbmhlcml0JyxcbiAgICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG4gICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnXG4gICAgICB9O1xuXG4gICAgICBmdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmUoZSkge1xuICAgICAgICBpZiAob25Nb3VzZU1vdmUpIHtcbiAgICAgICAgICBvbk1vdXNlTW92ZShpbmRleCwgZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaGFuZGxlTW91c2VDbGljayhlKSB7XG4gICAgICAgIGlmIChvbkNsaWNrKSB7XG4gICAgICAgICAgLy8gW1N1cHBvcnRpbmcgYm90aCBUb3VjaEV2ZW50IGFuZCBNb3VzZUV2ZW50XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVG91Y2hfZXZlbnRzL1N1cHBvcnRpbmdfYm90aF9Ub3VjaEV2ZW50X2FuZF9Nb3VzZUV2ZW50KVxuICAgICAgICAgIC8vIFdlIG11c3QgcHJldmVudCBmaXJpbmcgY2xpY2sgZXZlbnQgdHdpY2Ugb24gdG91Y2ggZGV2aWNlcy5cbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgb25DbGljayhpbmRleCwgZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICBvbkNsaWNrOiBoYW5kbGVNb3VzZUNsaWNrLFxuICAgICAgICBvbk1vdXNlTW92ZTogaGFuZGxlTW91c2VNb3ZlLFxuICAgICAgICBvblRvdWNoTW92ZTogaGFuZGxlTW91c2VNb3ZlLFxuICAgICAgICBvblRvdWNoRW5kOiBoYW5kbGVNb3VzZUNsaWNrXG4gICAgICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgICAgIHN0eWxlOiBiZ0ljb25Db250YWluZXJTdHlsZVxuICAgICAgfSwgYmFja2dyb3VuZE5vZGUpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgICAgIHN0eWxlOiBpY29uQ29udGFpbmVyU3R5bGVcbiAgICAgIH0sIGljb25Ob2RlKSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFJhdGluZ1N5bWJvbDtcbn0oUmVhY3QuUHVyZUNvbXBvbmVudCk7IC8vIERlZmluZSBwcm9wVHlwZXMgb25seSBpbiBkZXZlbG9wbWVudC4gVGhleSB3aWxsIGJlIHZvaWQgaW4gcHJvZHVjdGlvbi5cblxudmFyIFJhdGluZyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1JlYWN0JFB1cmVDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFJhdGluZywgX1JlYWN0JFB1cmVDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFJhdGluZyhwcm9wcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSYXRpbmcpO1xuXG4gICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoUmF0aW5nKS5jYWxsKHRoaXMsIHByb3BzKSk7XG4gICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAvLyBJbmRpY2F0ZXMgdGhlIHZhbHVlIHRoYXQgaXMgZGlzcGxheWVkIHRvIHRoZSB1c2VyIGluIHRoZSBmb3JtIG9mIHN5bWJvbHMuXG4gICAgICAvLyBJdCBjYW4gYmUgZWl0aGVyIDAgKGZvciBubyBkaXNwbGF5ZWQgc3ltYm9scykgb3IgKDAsIGVuZF1cbiAgICAgIGRpc3BsYXlWYWx1ZTogX3RoaXMucHJvcHMudmFsdWUsXG4gICAgICAvLyBJbmRpY2F0ZXMgaWYgdGhlIHVzZXIgaXMgY3VycmVudGx5IGhvdmVyaW5nIG92ZXIgdGhlIHJhdGluZyBlbGVtZW50XG4gICAgICBpbnRlcmFjdGluZzogZmFsc2VcbiAgICB9O1xuICAgIF90aGlzLm9uTW91c2VMZWF2ZSA9IF90aGlzLm9uTW91c2VMZWF2ZS5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpKTtcbiAgICBfdGhpcy5zeW1ib2xNb3VzZU1vdmUgPSBfdGhpcy5zeW1ib2xNb3VzZU1vdmUuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKSk7XG4gICAgX3RoaXMuc3ltYm9sQ2xpY2sgPSBfdGhpcy5zeW1ib2xDbGljay5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUmF0aW5nLCBbe1xuICAgIGtleTogXCJVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgIHZhciB2YWx1ZUNoYW5nZWQgPSB0aGlzLnByb3BzLnZhbHVlICE9PSBuZXh0UHJvcHMudmFsdWU7XG4gICAgICB0aGlzLnNldFN0YXRlKGZ1bmN0aW9uIChwcmV2U3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkaXNwbGF5VmFsdWU6IHZhbHVlQ2hhbmdlZCA/IG5leHRQcm9wcy52YWx1ZSA6IHByZXZTdGF0ZS5kaXNwbGF5VmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wb25lbnREaWRVcGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlKSB7XG4gICAgICAvLyBJZ25vcmUgc3RhdGUgdXBkYXRlIGR1ZSB0byB2YWx1ZSBjaGFuZ2VkIGZyb20gcHJvcHMuXG4gICAgICAvLyBVc3VhbGx5IG9yaWdpbmF0ZWQgdGhyb3VnaCBhbiBvbkNsaWNrIGV2ZW50LlxuICAgICAgaWYgKHByZXZQcm9wcy52YWx1ZSAhPT0gdGhpcy5wcm9wcy52YWx1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIFdoZW4gaG92ZXIgZW5kcywgY2FsbCB0aGlzLnByb3BzLm9uSG92ZXIgd2l0aCBubyB2YWx1ZS5cblxuXG4gICAgICBpZiAocHJldlN0YXRlLmludGVyYWN0aW5nICYmICF0aGlzLnN0YXRlLmludGVyYWN0aW5nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLm9uSG92ZXIoKTtcbiAgICAgIH0gLy8gV2hlbiBob3ZlciBvdmVyLlxuXG5cbiAgICAgIGlmICh0aGlzLnN0YXRlLmludGVyYWN0aW5nKSB7XG4gICAgICAgIHRoaXMucHJvcHMub25Ib3Zlcih0aGlzLnN0YXRlLmRpc3BsYXlWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN5bWJvbENsaWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN5bWJvbENsaWNrKHN5bWJvbEluZGV4LCBldmVudCkge1xuICAgICAgdmFyIHZhbHVlID0gdGhpcy5jYWxjdWxhdGVEaXNwbGF5VmFsdWUoc3ltYm9sSW5kZXgsIGV2ZW50KTtcbiAgICAgIHRoaXMucHJvcHMub25DbGljayh2YWx1ZSwgZXZlbnQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzeW1ib2xNb3VzZU1vdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3ltYm9sTW91c2VNb3ZlKHN5bWJvbEluZGV4LCBldmVudCkge1xuICAgICAgdmFyIHZhbHVlID0gdGhpcy5jYWxjdWxhdGVEaXNwbGF5VmFsdWUoc3ltYm9sSW5kZXgsIGV2ZW50KTsgLy8gVGhpcyBjYWxsIHNob3VsZCBjYXVzZSBhbiB1cGRhdGUgb25seSBpZiB0aGUgc3RhdGUgY2hhbmdlcy5cbiAgICAgIC8vIE1haW5seSB0aGUgZmlyc3QgdGltZSB0aGUgbW91c2UgZW50ZXJzIGFuZCB3aGVuZXZlciB0aGUgdmFsdWUgY2hhbmdlcy5cbiAgICAgIC8vIFNvIERpZENvbXBvbmVudFVwZGF0ZSBpcyBOT1QgY2FsbGVkIGZvciBldmVyeSBtb3VzZSBtb3ZlbWVudC5cblxuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGludGVyYWN0aW5nOiAhdGhpcy5wcm9wcy5yZWFkb25seSxcbiAgICAgICAgZGlzcGxheVZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9uTW91c2VMZWF2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbk1vdXNlTGVhdmUoKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgZGlzcGxheVZhbHVlOiB0aGlzLnByb3BzLnZhbHVlLFxuICAgICAgICBpbnRlcmFjdGluZzogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjYWxjdWxhdGVEaXNwbGF5VmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY3VsYXRlRGlzcGxheVZhbHVlKHN5bWJvbEluZGV4LCBldmVudCkge1xuICAgICAgdmFyIHBlcmNlbnRhZ2UgPSB0aGlzLmNhbGN1bGF0ZUhvdmVyUGVyY2VudGFnZShldmVudCk7IC8vIEdldCB0aGUgY2xvc2VzdCB0b3AgZnJhY3Rpb24uXG5cbiAgICAgIHZhciBmcmFjdGlvbiA9IE1hdGguY2VpbChwZXJjZW50YWdlICUgMSAqIHRoaXMucHJvcHMuZnJhY3Rpb25zKSAvIHRoaXMucHJvcHMuZnJhY3Rpb25zOyAvLyBUcnVuY2F0ZSBkZWNpbWFsIHRyeWluZyB0byBhdm9pZCBmbG9hdCBwcmVjaXNzaW9uIGlzc3Vlcy5cblxuICAgICAgdmFyIHByZWNpc2lvbiA9IE1hdGgucG93KDEwLCAzKTtcbiAgICAgIHZhciBkaXNwbGF5VmFsdWUgPSBzeW1ib2xJbmRleCArIChNYXRoLmZsb29yKHBlcmNlbnRhZ2UpICsgTWF0aC5mbG9vcihmcmFjdGlvbiAqIHByZWNpc2lvbikgLyBwcmVjaXNpb24pOyAvLyBlbnN1cmUgdGhlIHJldHVybmVkIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiAwIGFuZCBsb3dlciB0aGFuIHRvdGFsU3ltYm9sc1xuXG4gICAgICByZXR1cm4gZGlzcGxheVZhbHVlID4gMCA/IGRpc3BsYXlWYWx1ZSA+IHRoaXMucHJvcHMudG90YWxTeW1ib2xzID8gdGhpcy5wcm9wcy50b3RhbFN5bWJvbHMgOiBkaXNwbGF5VmFsdWUgOiAxIC8gdGhpcy5wcm9wcy5mcmFjdGlvbnM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNhbGN1bGF0ZUhvdmVyUGVyY2VudGFnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjdWxhdGVIb3ZlclBlcmNlbnRhZ2UoZXZlbnQpIHtcbiAgICAgIHZhciBjbGllbnRYID0gZXZlbnQubmF0aXZlRXZlbnQudHlwZS5pbmRleE9mKFwidG91Y2hcIikgPiAtMSA/IGV2ZW50Lm5hdGl2ZUV2ZW50LnR5cGUuaW5kZXhPZihcInRvdWNoZW5kXCIpID4gLTEgPyBldmVudC5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRYIDogZXZlbnQudG91Y2hlc1swXS5jbGllbnRYIDogZXZlbnQuY2xpZW50WDtcbiAgICAgIHZhciB0YXJnZXRSZWN0ID0gZXZlbnQudGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIGRlbHRhID0gdGhpcy5wcm9wcy5kaXJlY3Rpb24gPT09ICdydGwnID8gdGFyZ2V0UmVjdC5yaWdodCAtIGNsaWVudFggOiBjbGllbnRYIC0gdGFyZ2V0UmVjdC5sZWZ0OyAvLyBSZXR1cm5pbmcgMCBpZiB0aGUgZGVsdGEgaXMgbmVnYXRpdmUgc29sdmVzIHRoZSBmbGlja2VyaW5nIGlzc3VlXG5cbiAgICAgIHJldHVybiBkZWx0YSA8IDAgPyAwIDogZGVsdGEgLyB0YXJnZXRSZWN0LndpZHRoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICByZWFkb25seSA9IF90aGlzJHByb3BzLnJlYWRvbmx5LFxuICAgICAgICAgIHF1aWV0ID0gX3RoaXMkcHJvcHMucXVpZXQsXG4gICAgICAgICAgdG90YWxTeW1ib2xzID0gX3RoaXMkcHJvcHMudG90YWxTeW1ib2xzLFxuICAgICAgICAgIHZhbHVlID0gX3RoaXMkcHJvcHMudmFsdWUsXG4gICAgICAgICAgcGxhY2Vob2xkZXJWYWx1ZSA9IF90aGlzJHByb3BzLnBsYWNlaG9sZGVyVmFsdWUsXG4gICAgICAgICAgZGlyZWN0aW9uID0gX3RoaXMkcHJvcHMuZGlyZWN0aW9uLFxuICAgICAgICAgIGVtcHR5U3ltYm9sID0gX3RoaXMkcHJvcHMuZW1wdHlTeW1ib2wsXG4gICAgICAgICAgZnVsbFN5bWJvbCA9IF90aGlzJHByb3BzLmZ1bGxTeW1ib2wsXG4gICAgICAgICAgcGxhY2Vob2xkZXJTeW1ib2wgPSBfdGhpcyRwcm9wcy5wbGFjZWhvbGRlclN5bWJvbCxcbiAgICAgICAgICBjbGFzc05hbWUgPSBfdGhpcyRwcm9wcy5jbGFzc05hbWUsXG4gICAgICAgICAgaWQgPSBfdGhpcyRwcm9wcy5pZCxcbiAgICAgICAgICBzdHlsZSA9IF90aGlzJHByb3BzLnN0eWxlLFxuICAgICAgICAgIHRhYkluZGV4ID0gX3RoaXMkcHJvcHMudGFiSW5kZXg7XG4gICAgICB2YXIgX3RoaXMkc3RhdGUgPSB0aGlzLnN0YXRlLFxuICAgICAgICAgIGRpc3BsYXlWYWx1ZSA9IF90aGlzJHN0YXRlLmRpc3BsYXlWYWx1ZSxcbiAgICAgICAgICBpbnRlcmFjdGluZyA9IF90aGlzJHN0YXRlLmludGVyYWN0aW5nO1xuICAgICAgdmFyIHN5bWJvbE5vZGVzID0gW107XG4gICAgICB2YXIgZW1wdHkgPSBbXS5jb25jYXQoZW1wdHlTeW1ib2wpO1xuICAgICAgdmFyIGZ1bGwgPSBbXS5jb25jYXQoZnVsbFN5bWJvbCk7XG4gICAgICB2YXIgcGxhY2Vob2xkZXIgPSBbXS5jb25jYXQocGxhY2Vob2xkZXJTeW1ib2wpO1xuICAgICAgdmFyIHNob3VsZERpc3BsYXlQbGFjZWhvbGRlciA9IHBsYWNlaG9sZGVyVmFsdWUgIT09IDAgJiYgdmFsdWUgPT09IDAgJiYgIWludGVyYWN0aW5nOyAvLyBUaGUgdmFsdWUgdGhhdCB3aWxsIGJlIHVzZWQgYXMgYmFzZSBmb3IgY2FsY3VsYXRpbmcgaG93IHRvIHJlbmRlciB0aGUgc3ltYm9sc1xuXG4gICAgICB2YXIgcmVuZGVyZWRWYWx1ZTtcblxuICAgICAgaWYgKHNob3VsZERpc3BsYXlQbGFjZWhvbGRlcikge1xuICAgICAgICByZW5kZXJlZFZhbHVlID0gcGxhY2Vob2xkZXJWYWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbmRlcmVkVmFsdWUgPSBxdWlldCA/IHZhbHVlIDogZGlzcGxheVZhbHVlO1xuICAgICAgfSAvLyBUaGUgYW1vdW50IG9mIGZ1bGwgc3ltYm9sc1xuXG5cbiAgICAgIHZhciBmdWxsU3ltYm9scyA9IE1hdGguZmxvb3IocmVuZGVyZWRWYWx1ZSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG90YWxTeW1ib2xzOyBpKyspIHtcbiAgICAgICAgdmFyIHBlcmNlbnQgPSB2b2lkIDA7IC8vIENhbGN1bGF0ZSBlYWNoIHN5bWJvbCdzIGZ1bGxuZXNzIHBlcmNlbnRhZ2VcblxuICAgICAgICBpZiAoaSAtIGZ1bGxTeW1ib2xzIDwgMCkge1xuICAgICAgICAgIHBlcmNlbnQgPSAxMDA7XG4gICAgICAgIH0gZWxzZSBpZiAoaSAtIGZ1bGxTeW1ib2xzID09PSAwKSB7XG4gICAgICAgICAgcGVyY2VudCA9IChyZW5kZXJlZFZhbHVlIC0gaSkgKiAxMDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVyY2VudCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBzeW1ib2xOb2Rlcy5wdXNoKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmF0aW5nU3ltYm9sLCBfZXh0ZW5kcyh7XG4gICAgICAgICAga2V5OiBpLFxuICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgIHJlYWRvbmx5OiByZWFkb25seSxcbiAgICAgICAgICBpbmFjdGl2ZUljb246IGVtcHR5W2kgJSBlbXB0eS5sZW5ndGhdLFxuICAgICAgICAgIGFjdGl2ZUljb246IHNob3VsZERpc3BsYXlQbGFjZWhvbGRlciA/IHBsYWNlaG9sZGVyW2kgJSBmdWxsLmxlbmd0aF0gOiBmdWxsW2kgJSBmdWxsLmxlbmd0aF0sXG4gICAgICAgICAgcGVyY2VudDogcGVyY2VudCxcbiAgICAgICAgICBkaXJlY3Rpb246IGRpcmVjdGlvblxuICAgICAgICB9LCAhcmVhZG9ubHkgJiYge1xuICAgICAgICAgIG9uQ2xpY2s6IHRoaXMuc3ltYm9sQ2xpY2ssXG4gICAgICAgICAgb25Nb3VzZU1vdmU6IHRoaXMuc3ltYm9sTW91c2VNb3ZlLFxuICAgICAgICAgIG9uVG91Y2hNb3ZlOiB0aGlzLnN5bWJvbE1vdXNlTW92ZSxcbiAgICAgICAgICBvblRvdWNoRW5kOiB0aGlzLnN5bWJvbENsaWNrXG4gICAgICAgIH0pKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBfZXh0ZW5kcyh7XG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgc3R5bGU6IF9vYmplY3RTcHJlYWQoe30sIHN0eWxlLCB7XG4gICAgICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG4gICAgICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb25cbiAgICAgICAgfSksXG4gICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgICAgICB0YWJJbmRleDogdGFiSW5kZXgsXG4gICAgICAgIFwiYXJpYS1sYWJlbFwiOiB0aGlzLnByb3BzWydhcmlhLWxhYmVsJ11cbiAgICAgIH0sICFyZWFkb25seSAmJiB7XG4gICAgICAgIG9uTW91c2VMZWF2ZTogdGhpcy5vbk1vdXNlTGVhdmVcbiAgICAgIH0pLCBzeW1ib2xOb2Rlcyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFJhdGluZztcbn0oUmVhY3QuUHVyZUNvbXBvbmVudCk7IC8vIERlZmluZSBwcm9wVHlwZXMgb25seSBpbiBkZXZlbG9wbWVudC5cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbm5vb3AuX25hbWUgPSAncmVhY3RfcmF0aW5nX25vb3AnO1xuXG52YXIgUmF0aW5nQVBJTGF5ZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9SZWFjdCRQdXJlQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhSYXRpbmdBUElMYXllciwgX1JlYWN0JFB1cmVDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFJhdGluZ0FQSUxheWVyKHByb3BzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJhdGluZ0FQSUxheWVyKTtcblxuICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKFJhdGluZ0FQSUxheWVyKS5jYWxsKHRoaXMsIHByb3BzKSk7XG4gICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICB2YWx1ZTogcHJvcHMuaW5pdGlhbFJhdGluZ1xuICAgIH07XG4gICAgX3RoaXMuaGFuZGxlQ2xpY2sgPSBfdGhpcy5oYW5kbGVDbGljay5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpKTtcbiAgICBfdGhpcy5oYW5kbGVIb3ZlciA9IF90aGlzLmhhbmRsZUhvdmVyLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSkpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhSYXRpbmdBUElMYXllciwgW3tcbiAgICBrZXk6IFwiVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgdmFsdWU6IG5leHRQcm9wcy5pbml0aWFsUmF0aW5nXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlQ2xpY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlQ2xpY2sodmFsdWUsIGUpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgbmV3VmFsdWUgPSB0aGlzLnRyYW5zbGF0ZURpc3BsYXlWYWx1ZVRvVmFsdWUodmFsdWUpO1xuICAgICAgdGhpcy5wcm9wcy5vbkNsaWNrKG5ld1ZhbHVlKTsgLy8gQXZvaWQgY2FsbGluZyBzZXRTdGF0ZSBpZiBub3QgbmVjZXNzYXJ5LiBNaWNybyBvcHRpbWlzYXRpb24uXG5cbiAgICAgIGlmICh0aGlzLnN0YXRlLnZhbHVlICE9PSBuZXdWYWx1ZSkge1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgbmV3IHZhbHVlIHRyaWdnZXIgb25DaGFuZ2UgY2FsbGJhY2suXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIHZhbHVlOiBuZXdWYWx1ZVxuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi5wcm9wcy5vbkNoYW5nZShfdGhpczIuc3RhdGUudmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlSG92ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlSG92ZXIoZGlzcGxheVZhbHVlKSB7XG4gICAgICB2YXIgdmFsdWUgPSBkaXNwbGF5VmFsdWUgPT09IHVuZGVmaW5lZCA/IGRpc3BsYXlWYWx1ZSA6IHRoaXMudHJhbnNsYXRlRGlzcGxheVZhbHVlVG9WYWx1ZShkaXNwbGF5VmFsdWUpO1xuICAgICAgdGhpcy5wcm9wcy5vbkhvdmVyKHZhbHVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidHJhbnNsYXRlRGlzcGxheVZhbHVlVG9WYWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0cmFuc2xhdGVEaXNwbGF5VmFsdWVUb1ZhbHVlKGRpc3BsYXlWYWx1ZSkge1xuICAgICAgdmFyIHRyYW5zbGF0ZWRWYWx1ZSA9IGRpc3BsYXlWYWx1ZSAqIHRoaXMucHJvcHMuc3RlcCArIHRoaXMucHJvcHMuc3RhcnQ7IC8vIG1pbmltdW0gdmFsdWUgY2Fubm90IGJlIGVxdWFsIHRvIHN0YXJ0LCBzaW5jZSBpdCdzIGV4Y2x1c2l2ZVxuXG4gICAgICByZXR1cm4gdHJhbnNsYXRlZFZhbHVlID09PSB0aGlzLnByb3BzLnN0YXJ0ID8gdHJhbnNsYXRlZFZhbHVlICsgMSAvIHRoaXMucHJvcHMuZnJhY3Rpb25zIDogdHJhbnNsYXRlZFZhbHVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0cmFubGF0ZVZhbHVlVG9EaXNwbGF5VmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhbmxhdGVWYWx1ZVRvRGlzcGxheVZhbHVlKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICh2YWx1ZSAtIHRoaXMucHJvcHMuc3RhcnQpIC8gdGhpcy5wcm9wcy5zdGVwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBzdGVwID0gX3RoaXMkcHJvcHMuc3RlcCxcbiAgICAgICAgICBlbXB0eVN5bWJvbCA9IF90aGlzJHByb3BzLmVtcHR5U3ltYm9sLFxuICAgICAgICAgIGZ1bGxTeW1ib2wgPSBfdGhpcyRwcm9wcy5mdWxsU3ltYm9sLFxuICAgICAgICAgIHBsYWNlaG9sZGVyU3ltYm9sID0gX3RoaXMkcHJvcHMucGxhY2Vob2xkZXJTeW1ib2wsXG4gICAgICAgICAgcmVhZG9ubHkgPSBfdGhpcyRwcm9wcy5yZWFkb25seSxcbiAgICAgICAgICBxdWlldCA9IF90aGlzJHByb3BzLnF1aWV0LFxuICAgICAgICAgIGZyYWN0aW9ucyA9IF90aGlzJHByb3BzLmZyYWN0aW9ucyxcbiAgICAgICAgICBkaXJlY3Rpb24gPSBfdGhpcyRwcm9wcy5kaXJlY3Rpb24sXG4gICAgICAgICAgc3RhcnQgPSBfdGhpcyRwcm9wcy5zdGFydCxcbiAgICAgICAgICBzdG9wID0gX3RoaXMkcHJvcHMuc3RvcCxcbiAgICAgICAgICBpZCA9IF90aGlzJHByb3BzLmlkLFxuICAgICAgICAgIGNsYXNzTmFtZSA9IF90aGlzJHByb3BzLmNsYXNzTmFtZSxcbiAgICAgICAgICBzdHlsZSA9IF90aGlzJHByb3BzLnN0eWxlLFxuICAgICAgICAgIHRhYkluZGV4ID0gX3RoaXMkcHJvcHMudGFiSW5kZXg7XG5cbiAgICAgIGZ1bmN0aW9uIGNhbGN1bGF0ZVRvdGFsU3ltYm9scyhzdGFydCwgc3RvcCwgc3RlcCkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcigoc3RvcCAtIHN0YXJ0KSAvIHN0ZXApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSYXRpbmcsIHtcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICBzdHlsZTogc3R5bGUsXG4gICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgICAgICB0YWJJbmRleDogdGFiSW5kZXgsXG4gICAgICAgIFwiYXJpYS1sYWJlbFwiOiB0aGlzLnByb3BzWydhcmlhLWxhYmVsJ10sXG4gICAgICAgIHRvdGFsU3ltYm9sczogY2FsY3VsYXRlVG90YWxTeW1ib2xzKHN0YXJ0LCBzdG9wLCBzdGVwKSxcbiAgICAgICAgdmFsdWU6IHRoaXMudHJhbmxhdGVWYWx1ZVRvRGlzcGxheVZhbHVlKHRoaXMuc3RhdGUudmFsdWUpLFxuICAgICAgICBwbGFjZWhvbGRlclZhbHVlOiB0aGlzLnRyYW5sYXRlVmFsdWVUb0Rpc3BsYXlWYWx1ZSh0aGlzLnByb3BzLnBsYWNlaG9sZGVyUmF0aW5nKSxcbiAgICAgICAgcmVhZG9ubHk6IHJlYWRvbmx5LFxuICAgICAgICBxdWlldDogcXVpZXQsXG4gICAgICAgIGZyYWN0aW9uczogZnJhY3Rpb25zLFxuICAgICAgICBkaXJlY3Rpb246IGRpcmVjdGlvbixcbiAgICAgICAgZW1wdHlTeW1ib2w6IGVtcHR5U3ltYm9sLFxuICAgICAgICBmdWxsU3ltYm9sOiBmdWxsU3ltYm9sLFxuICAgICAgICBwbGFjZWhvbGRlclN5bWJvbDogcGxhY2Vob2xkZXJTeW1ib2wsXG4gICAgICAgIG9uQ2xpY2s6IHRoaXMuaGFuZGxlQ2xpY2ssXG4gICAgICAgIG9uSG92ZXI6IHRoaXMuaGFuZGxlSG92ZXJcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBSYXRpbmdBUElMYXllcjtcbn0oUmVhY3QuUHVyZUNvbXBvbmVudCk7XG5cblJhdGluZ0FQSUxheWVyLmRlZmF1bHRQcm9wcyA9IHtcbiAgc3RhcnQ6IDAsXG4gIHN0b3A6IDUsXG4gIHN0ZXA6IDEsXG4gIHJlYWRvbmx5OiBmYWxzZSxcbiAgcXVpZXQ6IGZhbHNlLFxuICBmcmFjdGlvbnM6IDEsXG4gIGRpcmVjdGlvbjogJ2x0cicsXG4gIG9uSG92ZXI6IG5vb3AsXG4gIG9uQ2xpY2s6IG5vb3AsXG4gIG9uQ2hhbmdlOiBub29wLFxuICBlbXB0eVN5bWJvbDogU3R5bGUuZW1wdHksXG4gIGZ1bGxTeW1ib2w6IFN0eWxlLmZ1bGwsXG4gIHBsYWNlaG9sZGVyU3ltYm9sOiBTdHlsZS5wbGFjZWhvbGRlclxufTsgLy8gRGVmaW5lIHByb3BUeXBlcyBvbmx5IGluIGRldmVsb3BtZW50LlxuXG5leHBvcnQgZGVmYXVsdCBSYXRpbmdBUElMYXllcjtcbiJdLCJuYW1lcyI6WyJSZWFjdCIsIl90eXBlb2YiLCJvYmoiLCJTeW1ib2wiLCJpdGVyYXRvciIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIlR5cGVFcnJvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwidGFyZ2V0IiwicHJvcHMiLCJpIiwibGVuZ3RoIiwiZGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5Iiwia2V5IiwiX2NyZWF0ZUNsYXNzIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX2RlZmluZVByb3BlcnR5IiwidmFsdWUiLCJfZXh0ZW5kcyIsImFzc2lnbiIsImFyZ3VtZW50cyIsInNvdXJjZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImFwcGx5IiwiX29iamVjdFNwcmVhZCIsIm93bktleXMiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiY29uY2F0IiwiZmlsdGVyIiwic3ltIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZm9yRWFjaCIsIl9pbmhlcml0cyIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsImNyZWF0ZSIsIl9zZXRQcm90b3R5cGVPZiIsIl9nZXRQcm90b3R5cGVPZiIsIm8iLCJzZXRQcm90b3R5cGVPZiIsImdldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwicCIsIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJzZWxmIiwiUmVmZXJlbmNlRXJyb3IiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsInN0eWxlIiwiZGlzcGxheSIsImJvcmRlclJhZGl1cyIsImJvcmRlciIsIndpZHRoIiwiaGVpZ2h0IiwiU3R5bGUiLCJlbXB0eSIsImJhY2tncm91bmRDb2xvciIsImZ1bGwiLCJwbGFjZWhvbGRlciIsIl9pY29uTm9kZSIsImljb24iLCJpc1ZhbGlkRWxlbWVudCIsImNyZWF0ZUVsZW1lbnQiLCJ0b1N0cmluZyIsImNsYXNzTmFtZSIsIlJhdGluZ1N5bWJvbCIsIl9SZWFjdCRQdXJlQ29tcG9uZW50IiwicmVuZGVyIiwiX2ljb25Db250YWluZXJTdHlsZSIsIl90aGlzJHByb3BzIiwiaW5kZXgiLCJpbmFjdGl2ZUljb24iLCJhY3RpdmVJY29uIiwicGVyY2VudCIsImRpcmVjdGlvbiIsInJlYWRvbmx5Iiwib25DbGljayIsIm9uTW91c2VNb3ZlIiwiYmFja2dyb3VuZE5vZGUiLCJzaG93YmdJY29uIiwiYmdJY29uQ29udGFpbmVyU3R5bGUiLCJ2aXNpYmlsaXR5IiwiaWNvbk5vZGUiLCJpY29uQ29udGFpbmVyU3R5bGUiLCJwb3NpdGlvbiIsIm92ZXJmbG93IiwidG9wIiwiY3Vyc29yIiwiaGFuZGxlTW91c2VNb3ZlIiwiZSIsImhhbmRsZU1vdXNlQ2xpY2siLCJwcmV2ZW50RGVmYXVsdCIsIm9uVG91Y2hNb3ZlIiwib25Ub3VjaEVuZCIsIlB1cmVDb21wb25lbnQiLCJSYXRpbmciLCJfdGhpcyIsInN0YXRlIiwiZGlzcGxheVZhbHVlIiwiaW50ZXJhY3RpbmciLCJvbk1vdXNlTGVhdmUiLCJiaW5kIiwic3ltYm9sTW91c2VNb3ZlIiwic3ltYm9sQ2xpY2siLCJVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyIsIm5leHRQcm9wcyIsInZhbHVlQ2hhbmdlZCIsInNldFN0YXRlIiwicHJldlN0YXRlIiwiY29tcG9uZW50RGlkVXBkYXRlIiwicHJldlByb3BzIiwib25Ib3ZlciIsInN5bWJvbEluZGV4IiwiZXZlbnQiLCJjYWxjdWxhdGVEaXNwbGF5VmFsdWUiLCJwZXJjZW50YWdlIiwiY2FsY3VsYXRlSG92ZXJQZXJjZW50YWdlIiwiZnJhY3Rpb24iLCJNYXRoIiwiY2VpbCIsImZyYWN0aW9ucyIsInByZWNpc2lvbiIsInBvdyIsImZsb29yIiwidG90YWxTeW1ib2xzIiwiY2xpZW50WCIsIm5hdGl2ZUV2ZW50IiwidHlwZSIsImluZGV4T2YiLCJjaGFuZ2VkVG91Y2hlcyIsInRvdWNoZXMiLCJ0YXJnZXRSZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiZGVsdGEiLCJyaWdodCIsImxlZnQiLCJxdWlldCIsInBsYWNlaG9sZGVyVmFsdWUiLCJlbXB0eVN5bWJvbCIsImZ1bGxTeW1ib2wiLCJwbGFjZWhvbGRlclN5bWJvbCIsImlkIiwidGFiSW5kZXgiLCJfdGhpcyRzdGF0ZSIsInN5bWJvbE5vZGVzIiwic2hvdWxkRGlzcGxheVBsYWNlaG9sZGVyIiwicmVuZGVyZWRWYWx1ZSIsImZ1bGxTeW1ib2xzIiwicHVzaCIsIm5vb3AiLCJfbmFtZSIsIlJhdGluZ0FQSUxheWVyIiwiaW5pdGlhbFJhdGluZyIsImhhbmRsZUNsaWNrIiwiaGFuZGxlSG92ZXIiLCJfdGhpczIiLCJuZXdWYWx1ZSIsInRyYW5zbGF0ZURpc3BsYXlWYWx1ZVRvVmFsdWUiLCJvbkNoYW5nZSIsInVuZGVmaW5lZCIsInRyYW5zbGF0ZWRWYWx1ZSIsInN0ZXAiLCJzdGFydCIsInRyYW5sYXRlVmFsdWVUb0Rpc3BsYXlWYWx1ZSIsInN0b3AiLCJjYWxjdWxhdGVUb3RhbFN5bWJvbHMiLCJwbGFjZWhvbGRlclJhdGluZyIsImRlZmF1bHRQcm9wcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-rating/lib/react-rating.esm.js\n");

/***/ })

};
;